<!DOCTYPE html>
<html>
<head>
  <title>Verfolger â€“ Block-Falle & Abstand</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: black;
      overflow: hidden;
      font-family: sans-serif;
      color: white;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #111;
      border: 2px solid #444;
    }
    .overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
    }
    button {
      padding: 15px 30px;
      font-size: 18px;
      margin-top: 20px;
      background: limegreen;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background: green;
    }
    #gameOverScreen, #levelCompleteScreen {
      display: none;
    }
  </style>
</head>
<body>
  <div id="startScreen" class="overlay">
    <h1>Verfolger-Spiel</h1>
    <button id="startButton">Start</button>
  </div>

  <div id="gameOverScreen" class="overlay">
    <h1>Game Over</h1>
    <p id="finalScore"></p>
    <button id="restartButton">Erneut spielen</button>
  </div>

  <div id="levelCompleteScreen" class="overlay">
    <h1>Level geschafft!</h1>
    <p id="finalScoreWin"></p>
    <button onclick="location.reload()">Neustarten</button>
  </div>

  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const keys = {};
    const blocks = [];
    const MIN_DISTANCE = 60;

    let player, chaser;
    let gameRunning = false;
    let gameLoopId;
    let blockInterval;
    let score = 0;
    let scoreInterval;
    let levelTimer;
    let teleporting = false;
    let levelDuration = 60000;

    function resizeCanvas() {
      const aspect = 16 / 9;
      const width = window.innerWidth;
      const height = window.innerHeight;

      if (width / height > aspect) {
        canvas.height = height;
        canvas.width = height * aspect;
      } else {
        canvas.width = width;
        canvas.height = width / aspect;
      }
    }

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("orientationchange", () => setTimeout(resizeCanvas, 200));

    function getWallHeight() {
      return canvas.height / 8;
    }

    function resetGameState() {
      const wallHeight = getWallHeight();
      player = {
        x: canvas.width * 0.2,
        y: canvas.height - wallHeight - 20,
        width: 20,
        height: 20,
        color: "lime",
        speed: 3,
        velY: 0,
        jumpForce: 7,
        gravity: 0.4,
        grounded: false,
        visible: true,
        blocked: false
      };

      chaser = {
        x: canvas.width * 0.05,
        y: canvas.height - wallHeight - 20,
        width: 20,
        height: 20,
        color: "red",
        speed: 1.5
      };

      blocks.length = 0;
      score = 0;
    }

    function spawnBlock() {
      if (!gameRunning) return;
      const wallHeight = getWallHeight();
      const width = Math.random() * 50 + 30;
      const height = Math.random() * 80 + 20;
      const fromTop = Math.random() < 0.5;
      const y = fromTop ? wallHeight : canvas.height - wallHeight - height;

      blocks.push({
        x: canvas.width,
        y,
        width,
        height,
        color: "#888",
        speed: 2
      });
    }

    function drawWalls() {
      const wallHeight = getWallHeight();
      ctx.fillStyle = "#444";
      ctx.fillRect(0, 0, canvas.width, wallHeight);
      ctx.fillRect(0, canvas.height - wallHeight, canvas.width, wallHeight);
    }

    function drawRect(obj) {
      if (obj.visible !== false) {
        ctx.fillStyle = obj.color;
        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
      }
    }

    function drawScore() {
      ctx.fillStyle = "white";
      ctx.font = "16px Arial";
      ctx.fillText("Punkte: " + score, 10, 30);
    }

    function movePlayer() {
      const wallHeight = getWallHeight();
      if (keys["a"]) player.x -= player.speed;
      if (keys["d"]) player.x += player.speed;
      if (keys["w"] && player.grounded) {
        player.velY = -player.jumpForce;
        player.grounded = false;
      }

      player.velY += player.gravity;
      player.y += player.velY;

      const floorY = canvas.height - wallHeight - player.height;
      if (player.y > floorY) {
        player.y = floorY;
        player.velY = 0;
        player.grounded = true;
      }

      if (player.y < wallHeight) {
        player.y = wallHeight;
        player.velY = 0;
      }
    }

    function moveChaser() {
      const dx = player.x - chaser.x;
      const dy = player.y - chaser.y;
      const dist = Math.hypot(dx, dy);

      // Wenn Spieler blockiert ist, Verfolger darf aufholen
      if (dist > (player.blocked ? 1 : MIN_DISTANCE)) {
        chaser.x += (dx / dist) * chaser.speed;
        chaser.y += (dy / dist) * chaser.speed;
      }
    }

    function moveBlocks() {
      for (let block of blocks) {
        block.x -= block.speed;
      }
    }

    function checkBlockCollisions(entity) {
      entity.grounded = false;
      entity.blocked = false;
      const wallHeight = getWallHeight();

      for (let block of blocks) {
        const collided = (
          entity.x < block.x + block.width &&
          entity.x + entity.width > block.x &&
          entity.y < block.y + block.height &&
          entity.y + entity.height > block.y
        );

        if (collided) {
          entity.blocked = true;

          // einfache Kollision von oben
          if (entity.velY > 0) {
            entity.y = block.y - entity.height;
            entity.velY = 0;
            entity.grounded = true;
          } else if (entity.velY < 0) {
            entity.y = block.y + block.height;
            entity.velY = 0;
          }
        }
      }

      if (entity.y < wallHeight) {
        entity.y = wallHeight;
        entity.velY = 0;
      }
      if (entity.y > canvas.height - wallHeight - entity.height) {
        entity.y = canvas.height - wallHeight - entity.height;
        entity.velY = 0;
        entity.grounded = true;
      }
    }

    function checkGameOver() {
      if (
        player.x < chaser.x + chaser.width &&
        player.x + player.width > chaser.x &&
        player.y < chaser.y + chaser.height &&
        player.y + player.height > chaser.y
      ) {
        endGame();
      }
    }

    function endGame() {
      gameRunning = false;
      cancelAnimationFrame(gameLoopId);
      clearInterval(blockInterval);
      clearInterval(scoreInterval);
      clearTimeout(levelTimer);
      document.getElementById("finalScore").innerText = "Deine Punkte: " + score;
      document.getElementById("gameOverScreen").style.display = "flex";
    }

    function levelWon() {
      teleporting = true;
      let flashes = 6;
      const flashInterval = setInterval(() => {
        player.visible = !player.visible;
        flashes--;
        if (flashes <= 0) {
          clearInterval(flashInterval);
          player.visible = false;
          finishLevel();
        }
      }, 200);
    }

    function finishLevel() {
      gameRunning = false;
      cancelAnimationFrame(gameLoopId);
      clearInterval(blockInterval);
      clearInterval(scoreInterval);
      document.getElementById("finalScoreWin").innerText = "Deine Punkte: " + score;
      document.getElementById("levelCompleteScreen").style.display = "flex";
    }

    function gameLoop() {
      if (!gameRunning) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawWalls();
      movePlayer();
      moveChaser();
      moveBlocks();

      checkBlockCollisions(player);
      checkBlockCollisions(chaser);

      drawRect(player);
      drawRect(chaser);
      for (let block of blocks) drawRect(block);

      drawScore();
      if (!teleporting) checkGameOver();

      gameLoopId = requestAnimationFrame(gameLoop);
    }

    // Steuerung
    document.addEventListener("keydown", (e) => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", (e) => keys[e.key.toLowerCase()] = false);

    document.getElementById("startButton").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      teleporting = false;
      resetGameState();
      gameRunning = true;
      blockInterval = setInterval(spawnBlock, 1500);
      scoreInterval = setInterval(() => score++, 100);
      levelTimer = setTimeout(() => {
        if (gameRunning) levelWon();
      }, levelDuration);
      gameLoop();
    });

    document.getElementById("restartButton").addEventListener("click", () => {
      document.getElementById("gameOverScreen").style.display = "none";
      teleporting = false;
      resetGameState();
      gameRunning = true;
      blockInterval = setInterval(spawnBlock, 1500);
      scoreInterval = setInterval(() => score++, 100);
      levelTimer = setTimeout(() => {
        if (gameRunning) levelWon();
      }, levelDuration);
      gameLoop();
    });

    resetGameState();
  </script>
</body>
</html>
